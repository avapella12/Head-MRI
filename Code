import cv2
import numpy as np
from skimage import measure
from skimage.measure import regionprops
import matplotlib.pyplot as plt

class HeadMRIAnalysis:
    def __init__(self, image_path):
        self.image_path = image_path
        self.image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
        if self.image is None:
            raise ValueError("Image cannot be loaded, double check file path.")
        self.tumor_present = False
        self.tumor_type = "No tumor"
        self.tumor_size = (0, 0)
        self.tumor_location = (0, 0)
        self.processed_image = None

    def analyze(self):
        self._preprocess_image()
        self._detect_tumor()
        if self.tumor_present:
            self._classify_tumor()
            self._measure_size()

    def _preprocess_image(self):
        blurred = cv2.GaussianBlur(self.image, (5, 5), 0)
        clahe = cv2.createCLAHE(clipLimit = 2.0, tileGridSize = (8, 8))
        self.processed_image = clahe.apply(blurred)

    def _detect_tumor(self):
        threshold = cv2.adaptiveThreshold(
            self.processed_image, 255,
            cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
            cv2.THRESH_BINARY_INV, 11, 2) 

        kernel = np.ones((3, 3), np.uint8)
        cleaned = cv2.morphologyEx(threshold, cv2.MORPH_OPEN, kernel, iterations=2)
        cleaned = cv2.morphologyEx(cleaned, cv2.MORPH_CLOSE, kernel, iterations=4)        
        labels = measure.label(cleaned)        
        regions = regionprops(labels)        
        height, width = self.image.shape        
        min_area = 0.005 * height * width        
        max_area = 0.3 * height * width        
        potench_tumors = []        
        for region in regions:            
            if min_area < region.area < max_area:       
                mean_intensity = np.mean(self.image[region.coords[:,0], region.coords[:,1]])              
                if mean_intensity > np.mean(self.image) * 1.2:                
                    potench_tumors.append(region)
        if potench_tumors:
            largest_tumor = max(potench_tumors, key=lambda x: x.area)
            self.tumor_present = True
            self.tumor_location = largest_tumor.centroid
            self.tumor_mask = np.zeros_like(self.image, dtype=np.uint8)
            for coord in largest_tumor.coords:
                self.tumor_mask[coord[0], coord[1]] = 255

    def _classify_tumor(self):
      height, width = self.image.shape
      y, x = self.tumor_location
      pituitary_region = (
          width * 0.4 < x < width * 0.6 and
          height * 0.6 < y < height * 0.9)
      contours, _ = cv2.findContours(self.tumor_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
      if contours:
        cnt = max(contours, key = cv2.contourArea)
        hull = cv2.convexHull(cnt)
        hull_area = cv2.contourArea(hull)
        cnt_area = cv2.contourArea(cnt)
        solidity = float(cnt_area) / hull_area if hull_area > 0 else 0

        ellipse = cv2.fitEllipse(cnt)
        (center, axes, orientation) = ellipse
        major_axis, minor_axis = max(axes), min(axes)
        eccentricity = np.sqrt(1 - (minor_axis / major_axis) ** 2)

        meningioma = (
            solidity < 0.85 and
            eccentricity > 0.7 and
            not pituitary_region)
        else:
          meningioma = False

        if pituitary_region:
          self.tumor_type = "Pituitary Tumor"
        elif meningioma:
          self.tumor_type = "Meningioma"
        else:
          self.tumor_type = "Glioma"

    def _measure_size(self):
      contours, _ = cv2.findContours(self.tumor_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
      if contours:
        cnt = max(contours, key = cv2.contourArea)
        x, y, w, h = cv2.boundingRect(cnt)
        self.tumor_size = (w, h)

    def get_results(self):
        return {
            "tumor_present": self.tumor_present,
            "tumor_type": self.tumor_type,
            "tumor_size_pixels": self.tumor_size,
            "tumor_location": self.tumor_location}

    def visualize(self):
      if not hasattr(self, 'tumor_mask'):
        print("No tumor detected. Healthy physiology")
        return

      vis = cv2.cvtColor(self.image, cv2.COLOR_GRAY2BGR)
      vis[self.tumor_mask == 255] = [255, 0, 0]
      cv2.drawMarker(vis, int(self.tumor_location[1], int(self.tumor_location[0])),
       (0, 255, 0), markerType = cv2.MARKER_CROSS, markerSize = 20, thickness = 2)
      contours, _ = cv2.findContours(
          self.tumor_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
      if contours:
        cnt = max(contours, key = cv2.contourArea)
        x, y, w, h = cv2.boundingRect(cnt)
        cv2.rectangle(vis, (x, y), (x + w, y + h), (0, 255, 255), 2)

      plt.figure(figsize = (10, 10))
      plt.imshow(vis)
      plt.title(f"Tumor Analysis/nType: {self.tumor_type}/nSize: {self.tumor_size} pixels")
      plt.axis('off')
      plt.show()

if __name__ == "__main__":
  analyzer = HeadMRIAnalysis("image.jpg")
  analyzer.analyze()

  results = analyzer.get_results()
  print("Analysis Results:")
  print(f"Tumor Present: {results['tumor_present']}")
  print(f"Tumor Type: {results['tumor_type']}")
  print(f"Tumor Size (width, height in pixels): {results['tumor_size_pixels']}")
  print(f"Tumor Location (x, y): {results['tumor_location']}")

  analyzer.visualize()      
        

        